<!doctype html>
<htm lang="en">
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Security-Policy" content="frame-src https://www.buymeacoffee.com; style-src 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.rawgit.com 'self'; script-src 'sha256-nP0EI9B9ad8IoFUti2q7EQBabcE5MS5v0nkvRfUbYnM=' https://cdnjs.buymeacoffee.com https://code.jquery.com https://cdnjs.cloudflare.com https://cdn.rawgit.com https://pagead2.googlesyndication.com 'self'">
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta name="keywords" content="Django, web, programming, antipattern, pattern, troubleshooting, software design, django-models, django-views, django-templates, django-orm">
    <meta name="author" content="Willem Van Onsem">
    <meta name="description" content="A set of Django (anti)patterns: patterns and things to avoid when building a web application with Django.">
    <meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/257009680/7a954900-2f5d-11eb-8d0a-c8af0596107f" />
    <meta name="og:title" content="Signals" />
    <meta name="og:image" content="https://repository-images.githubusercontent.com/257009680/7a954900-2f5d-11eb-8d0a-c8af0596107f" />
    <meta name="og:image:alt" content="A prohibition sign in the Django color scheme." />
    <meta name="og:image:type" content="image/png" />
    <meta name="og:type" content="website" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/template.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.3.2/styles/default.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />

    <!-- <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" /> -->

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="/style.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.rawgit.com/ryangrose/easy-pandoc-templates/948e28e5/css/elegant_bootstrap.css" rel="stylesheet" type="text/css" />
  
    <!--script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script-->
  
    <!--script src="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/script.js"></script-->
  
    <script src="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/jquery.sticky-kit.js"></script>
    <script data-ad-client="ca-pub-9962024266760159" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="generator" content="pandoc" />
  <title>Django antipatterns &#x3009;antipattern &#x3009;Signals</title>
</head>
<body>
  <a class="github-fork-ribbon" href="https://github.com/hapytex/django-antipatterns" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">Signals</span>
        <ul class="nav pull-right doc-info">
                                        <li>
            <div class="rating" data-rating="3">
              severity:
              <i class="star-1">★</i>
              <i class="star-2">★</i>
              <i class="star-3">★</i>
              <i class="star-4">★</i>
              <i class="star-5">★</i>
            </div>
          </li>
                  </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div class="span12">
            <p>Django has a sophisticated system to trigger certain logic when you save, delete, change many-to-many relations, etc. Very often people make use of such signals and for some edge-cases these are indeed the only effective solution, but there are only a few cases where using signals is appropriate.</p>
<h1 id="why-is-it-a-problem">Why is it a problem?</h1>
<p>Signals have a variety of problems and unforseen consequences. In the below sections, we list a few.</p>
<h2 id="signals-can-be-circumvented">Signals can be circumvented</h2>
<p>One of the main problems with signals is that signals do <em>not</em> always run. Indeed the <code>pre_save</code> and <code>post_save</code> signals will <em>not</em> run when we save or update objects in bulk. For example if we create multiple <code>Post</code>s with:</p>
<pre class="python"><code>Post.objects.<b>bulk_create(</b>[
    Post(title='foo'),
    Post(title='bar'),
    Post(title='qux')
]<b>)</b></code></pre>
<p>then the signals do not run. The same happens when you update posts, for example with:</p>
<pre class="python"><code>Post.objects.all().<b>update(</b>views=0<b>)</b></code></pre>
<p>Often people assume that signals <em>will</em> run in that case, and for example perform calculations with the signals: they recalculate a certain field, based on the updated values. Since one can update a field <em>without</em> triggering the the corresponding signals, then this results in an inconsistent value. Signals thus give a <em>false sense of security</em> that the handler will indeed update the object accordingly.</p>
<h2 id="signals-can-raise-exceptions-and-break-the-code-flow">Signals can raise exceptions and break the code flow</h2>
<p>If the signals run, for example when we call <code>.save()</code> on a model object, then the triggers <em>will</em> run. Contrary to popular belief, signals do <em>not</em> run asynchronous, but in a synchronous manner: there is a list of functions and these will all run. A second problem is that these signals might raise an error, and this will thus result in the function that triggered the views, raising that error. Developers often do not take this into account.</p>
<p>If such error is raised, then eventually the <code>.save()</code> call will raise an error. Even if the developer takes this into account, it is hard to anticipate on the consequences: if there are multiple handlers for the same signal, then some of the handlers can have made changes whereas others might not have been invoked. It thus makes it more complicated to repair the object, since the handlers might already have changed the object partially.</p>
<h2 id="signals-can-result-in-infinite-recursion">Signals can result in infinite recursion</h2>
<p>It is also rather easy to get stuck in an infinite loop with signals. If we for example have a model of a <code>Profile</code> with a signal that will remove the <code>User</code> if we remove the <code>Profile</code>:</p>
<pre class="python"><code>from django.db import models
from django.db.models.signals import pre_delete
from django.dispatch import receiver

class Profile(models.Model):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE
    )

# &hellip;

@receiver(pre_delete, sender=Profile)
def delete_profile(sender, instance, using):
    instance.user.delete()</code></pre>
<p>If we now remove a <code>Profile</code>, this will get stuck in an infinite loop. Indeed, first we start removing a <code>Profile</code>. This will trigger the signal to run, which will remove the related user object. But Django will look what to do when removing the user, and it thus will <em>first</em> remove the <code>Profile</code> again triggering the signal. It is easy to end up with infinite recursion when defining signals. Especially if we use signals on two models that are related to each other.</p>
<h2 id="signals-run-before-updating-many-to-many-relations">Signals run before updating many-to-many relations</h2>
<p>The <code>pre_save</code> and <code>post_save</code> signals of an object run immediately before and after an object is saved to the database. If we have a model with a <code>ManyToManyField</code>, then when we create that object and the signals run, the <code>ManyToManyField</code> is <em>not</em> yet populated. This is because a <code>ModelForm</code> first needs to create the object, before that object has a primary key and thus can start populating the many-to-many relation. If we for example have two models <code>Author</code> and <code>Book</code> with a many-to-many relation, and we want to use a signal that counts the number of books an <code>Author</code> has written, then the following signal will not work when we create an <code>Author</code>, and the form also to specify the books:</p>
<pre class="python"><code>from django.db.models.signals import pre_save
from django.dispatch import receiver

@receiver(pre_save, sender=Author)
def save_author(sender, instance, created, raw, using, update_fields):
    instance.num_books = instance.books.count()</code></pre>
<p>Regardless whether we use a <code>pre_save</code> or <code>post_save</code> signal, at that moment in time <code>instance.books.all()</code> is an empty queryset.</p>
<h2 id="signals-make-altering-objects-less-predictable">Signals make altering objects less predictable</h2>
<p>Even if only one handler is attached to the the signal, and that handler can never raise an error, the handler still is often not an elegant solution. Another developer might not be aware of its existence, since it has only a &quot;weak&quot; binding to th model, and thus it makes the effect of saving an object less predictable.</p>
<h2 id="signals-do-not-run-when-other-programs-make-changes">Signals do not run when other programs make changes</h2>
<p>Finally other programs can also make changes to the database, and thus will not trigger the signals, and this eventually could lead to the database being in an inconsistent state. Another program could for example create a new book for an author, but might not update the field in the <code>Author</code> model that keeps track of the number of books written by that author. It will be quite hard to &quot;translate&quot; all the handlers in Django to other programs that interact with the same database.</p>
<h1 id="what-can-be-done-to-resolve-the-problem">What can be done to resolve the problem?</h1>
<p>Often it is better to avoid using signals. One can implement a lot of logic <em>without</em> signals.</p>
<h2 id="calculating-properties-on-demand">Calculating properties on-demand</h2>
<p>The most robust way to count the number of <code>Book</code>s of an <code>Author</code> is <em>not</em> to store the number of books in a field, but use <a href="https://docs.djangoproject.com/en/dev/ref/models/querysets/#annotate"><strong><code>.annotate(…)</code></strong> [Django-doc]</a> to each time annotate the <code>Author</code>s with the number of <code>Book</code>s they have written. We thus can make a query that looks like:</p>
<pre class="python3"><code>from django.db.models import <b>Count</b>

Author.objects.annotate(
    <b>num_books=Count('books')</b>
)</code></pre>
<p>Often if the number of <code>Book</code>s is not that large, this will still scale quite well. It is more robust: if somehow another program removed a book, or a view was triggered that somehow circumvented the update logic, it will still work with the correct amount of books.</p>
<p>Here of course we each time recalculate the number of <code>Book</code>s per <code>Author</code> when we query. If the number of <code>Book</code>s and <code>Author</code>s grows, then this can become a performance bottleneck.</p>
<h2 id="encapsulating-update-logic-in-the-viewform-and-modeladmin">Encapsulating update logic in the view/form and ModelAdmin</h2>
<p>Another option might be to encapsulate the handler logic in a specific function. For example if we want to count the number of books of an <code>Author</code> each time we save/update a <code>Book</code>, we can implement the logic:</p>
<pre class="python3"><code>def update_book(book):
    author = book.author
    author.num_books = author.books.count()
    author.save()</code></pre>
<p>and then we can call this function in the views where we create/update the book. For example:</p>
<pre class="python"><code>def my_view(request):
    if request.method == 'POST':
        form = BookForm(request.POST, request.FILES)
        if form.is_valid():
            book = form.save()
            <b>update_book(</b>book<b>)</b>
            # &hellip;
        # &hellip;
    # &hellip;</code></pre>
<p>we can also construct a mixin that we can use in class-based views and the <code>ModelAdmin</code>:</p>
<pre class="python3"><code>from django.contrib import admin

class MyModelAdmin(admin.ModelAdmin):
    
    def save_model(self, request, obj, form, change):
        &lt;b&gt;update_book(&lt;/b&gt;obj&lt;b&gt;)&lt;/b&gt;
        super().save_model(request, obj, form, change)</code></pre>
<h2 id="periodically-update-data">Periodically update data</h2>
<p>If the data depends on updates of a related model, and somehow we can not run logic when objects of that model are updated, we might schedule a periodic task.</p>
<h2 id="use-m2m_change-signals">Use <code>m2m_change</code> signals</h2>
<h1 id="extra-tips">Extra tips</h1>
<p>Signals can still be a good solution if you want to handle events raised by a <em>third party</em> Django application. In many cases, this is the only effective way to handle certain events. For example the <code>auth</code></p>
      <script nonce data-name="BMC-Widget" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="hapytex" data-description="Support me on Buy me a coffee!" data-message="Thank you for visiting." data-color="#FFDD00" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
      </div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.3.2/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
